```java
/*
*  1차 풀이 - 실패
*  정확성 테스트케이스 3가지만 성공.
*  실패원인: Map, stream 써보려고 하다가 쓸데없이 코드가 길어지고
            완주자가 동명이인이 모두 있을 경우 에러가 난다.
*/

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class SolutionHash1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String[] participant = {"mislav", "stanko", "mislav", "ana"};
		String[] completion =  {"stanko", "ana","mislav"};
		String answer = SolutionHash1.solution(participant, completion);
		
		System.out.println(answer);
	}
	
	
	public static String solution(String[] participant, String[] completion) {
		String answer = "";
		
		//validation
		if(participant.length < 1 || participant.length > 100000) {
			answer = "[error] Invalid participant length";
		}
		if(participant.length - 1 != completion.length) {
			answer += "[error] Invalid completion length ";
		}
		
		outerloop:
		for(int i=0; i < participant.length; i++) {
			for(int j=0; j < participant[i].length(); j++) {
				if( participant[i].charAt(j) >= 'a' && participant[i].charAt(j) <= 'z') {
					continue;
				}else {
					answer += "[error] Invalid name alphabet";
					break outerloop;
				}
			}
			
			if(participant[i].length() < 1 || participant[i].length() > 20 ) {
				answer += "[error] Invalid name length ";
				break;
			}
			
		}
		
		if("".equals(answer)) {
			List<String> completionList = Arrays.asList(completion);
			Map<String, String> completionMap = 
					completionList.stream()
								   .distinct()
								   .collect(Collectors.toMap( s1-> s1 , s1 -> s1));
			
			
			for(int i=0; i < participant.length; i++) {
				if(completionMap.containsKey(participant[i])) {
					completionMap.remove(participant[i]);
					continue;  
				}else {
					answer = participant[i];
					break;
				}
			    
				//System.out.println(participant[i] + ":" + completionMap.containsKey(participant[i]) );
			}
		}
		
        
        return answer;
    }

}

```

```java
/*
*  2차 풀이 - 실패
*  정확성 테스트케이스 5가지 모두 성공. 효율성 모두 실패
*  실패원인: Map, stream 을 사용하여 코드길어져 효율성 안좋음.
*           그래도 Map을 사용해보려는 개인적 목적은 달성.
            
*/
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SolutionHash1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String[] participant = {"mislav", "stanko", "mislav", "ana"};
		String[] completion =  {"stanko", "ana","mislav"};
		String answer = SolutionHash1.solution(participant, completion);
		
		System.out.println(answer);
	}
	
	
	public static String solution(String[] participant, String[] completion) {
		String answer = "";
		
		//validation
		if(participant.length < 1 || participant.length > 100000) {
			answer = "[error] Invalid participant length";
		}
		if(participant.length - 1 != completion.length) {
			answer += "[error] Invalid completion length ";
		}
		
		outerloop:
		for(int i=0; i < participant.length; i++) {
			for(int j=0; j < participant[i].length(); j++) {
				if( participant[i].charAt(j) >= 'a' && participant[i].charAt(j) <= 'z') {
					continue;
				}else {
					answer += "[error] Invalid name alphabet";
					break outerloop;
				}
			}
			
			if(participant[i].length() < 1 || participant[i].length() > 20 ) {
				answer += "[error] Invalid name length ";
				break;
			}
			
		}
		
		if("".equals(answer)) {
			List<String> completionList = Arrays.asList(completion);
			Map<Integer, String> completionMap = 
					completionList.stream()
								  .collect(HashMap<Integer, String>::new,
										  (map, streamValue) -> map.put(map.size(), streamValue),
										  (map, map2) -> {});
			
			
			List<Integer> listOfKeys = null;
			listOfKeys = new ArrayList<>();
			
			for(int i=0; i < participant.length; i++) {
				if(completionMap.containsValue(participant[i])) {					
					for (Map.Entry<Integer, String> entry : completionMap.entrySet() ) {
						if(entry.getValue().equals(participant[i]) && !listOfKeys.contains(entry.getKey())) {
							listOfKeys.add(entry.getKey());
							break;
						}
					}
					
					for(Integer key:listOfKeys) completionMap.remove(key);	
					continue;  
				}else {
					answer = participant[i];
					break;
				}
				
			}

		}
		
        
        return answer;
    }

}


```

